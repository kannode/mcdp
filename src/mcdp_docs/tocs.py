# -*- coding: utf-8 -*-

from collections import namedtuple

from bs4.element import Tag, NavigableString

from contracts import contract
from contracts.utils import indent
from mcdp.logs import logger
from mcdp_docs.check_missing_links import get_id2element
from mcdp_docs.location import HTMLIDLocation
from mcdp_utils_misc import AugmentedResult
from mcdp_utils_xml import add_class, bs
from .manual_constants import MCDPManualConstants, get_style_duckietown
from .toc_number import render_number, number_styles, ZERO


def element_has_one_of_prefixes(element, prefixes):
    eid = element.attrs.get('id', 'notpresent')
    return any(eid.startswith(_ + ':') for _ in prefixes)


class GlobalCounter(object):
    header_id = 1


def fix_ids_and_add_missing(soup, globally_unique_id_part, res, location):
    for h in soup.findAll(MCDPManualConstants.HEADERS_TO_FIX):
        fix_header_id(h, globally_unique_id_part, res, location)


def fix_header_id(header, globally_unique_id_part, res, location):
    ID = header.get('id', None)
    prefix = None if (ID is None or ':' not in ID) else ID[:ID.index(':')]

    if header.name in MCDPManualConstants.allowed_prefixes_h:
        allowed_prefixes = MCDPManualConstants.allowed_prefixes_h[header.name]
        default_prefix = allowed_prefixes[0]

        if ID is None:
            main = '%s-%s' % (globally_unique_id_part, GlobalCounter.header_id)
            use = '%s:%s' % (default_prefix, main)
            header.attrs['id'] = use
            header.attrs['id-short'] = main
            header.attrs['id-autogenerated'] = "true"
            GlobalCounter.header_id += 1
        else:
            if prefix is None:
                if ID != 'booktitle':  # XXX
                    # msg = ('Adding prefix %r to current id %r for %s.' %
                    #        (default_prefix, ID, header.name))
                    # header.insert_before(Comment('Warning: ' + msg))
                    header.attrs['id'] = default_prefix + ':' + ID
                    header.attrs['id-short'] = ID
            else:
                if prefix not in allowed_prefixes:
                    msg = ('The prefix %r is not allowed for %s (ID=%r)' %
                           (prefix, header.name, ID))
                    # logger.error(msg)  # TODO: add warning
                    # header.insert_after(Comment('Error: ' + msg))
                    res.note_error(msg, HTMLIDLocation.for_element(header, location))
                else:
                    ID_short = ID.replace(prefix + ':', '')
                    header.attrs['id-short'] = ID_short


class InvalidHeaders(ValueError):
    pass


def get_things_to_index(soup):
    """
        nothing with attribute "notoc"

        h1, h2, h3, h4, h5
        div  with id= "fig:*" or "tab:*" or "subfig:*" or "code:*"
        or div with ['exa', 'rem', 'lem', 'def', 'prop', 'prob', 'thm']
    """
    formatter = None

    THINGS_TO_INDEX = MCDPManualConstants.HEADERS_TO_INDEX + MCDPManualConstants.OTHER_THINGS_TO_INDEX
    for h in soup.findAll(THINGS_TO_INDEX):

        if formatter is None:
            # noinspection PyProtectedMember
            formatter = h._formatter_for_name("html")

        if h.has_attr(MCDPManualConstants.ATTR_NOTOC):
            continue

        if h.name in MCDPManualConstants.HEADERS_TO_INDEX:
            if 'id' not in h.attrs:
                msg = 'This header does not have an ID set.'
                msg += '\n header: ' + str(h)
                msg += '\nThe function fix_ids_and_add_missing() adds missing IDs.'
                raise InvalidHeaders(msg)

            h_id = h.attrs['id']
            if h.name == 'h1':
                if h_id.startswith('part:'):
                    depth = 1
                elif h_id.startswith('app:'):
                    depth = 2
                elif h_id.startswith('sec:'):
                    depth = 3
                elif h_id.startswith('book:'):
                    depth = 0
                else:
                    msg = 'I expected that this header would start with either part:, app:, sec:, or "book:".'
                    msg += '\n' + str(h)
                    msg += '\nThe function fix_ids_and_add_missing() adds missing IDs and fixes them.'
                    raise InvalidHeaders(msg)
            elif h.name == 'h2':
                depth = 4
            elif h.name == 'h3':
                depth = 5
            elif h.name == 'h4':
                depth = 6
            elif h.name == 'h5':  # XXX: never reach
                depth = 7
            elif h.name == 'h6':
                depth = 8
            else:
                assert False, h

            name = h.decode_contents(formatter=formatter)
            yield h, depth, name

        # elif h.name in ['figure']:
        if h.name in ['div', 'figure']:  # now figures are converted to div
            if element_has_one_of_prefixes(h, MCDPManualConstants.figure_prefixes):

                # XXX: bug because it gets confused with children
                figcaption = h.find('figcaption')
                if figcaption is None:
                    name = None
                else:
                    name = figcaption.decode_contents(formatter=formatter)
                yield h, 100, name

        if h.name in ['div']:
            if element_has_one_of_prefixes(h, MCDPManualConstants.div_latex_prefixes):
                label = h.find(class_='latex_env_label')
                if label is None:
                    name = None
                else:
                    name = label.decode_contents(formatter=formatter)
                yield h, 100, name


def generate_toc(soup, max_depth=None, max_levels=2, res=AugmentedResult()):
    max_levels += 1  # since we added "book"
    stack = [Item(None, -1, 'root', 'root', [])]

    headers_depths = list(get_things_to_index(soup))

    for header, depth, using in headers_depths:
        if max_depth is not None:
            if depth > max_depth:
                continue

        item = Item(header, depth, using, header['id'], [])

        while stack[-1].depth >= depth:
            stack.pop()

        stack[-1].items.append(item)
        stack.append(item)

    root = stack[0]

    number_items2(root, res)

    without_levels = root.copy_excluding_levels(MCDPManualConstants.exclude_from_toc)
    result = without_levels.to_html(root=True, max_levels=max_levels)

    if ZERO in result:
        res.note_error("Some counters had zero values")
    return result


def toc_summary(root):
    s = ''
    for item in root.depth_first_descendants():
        number = item.tag.attrs.get(LABEL_WHAT_NUMBER, '???')
        display_name = item.name
        if display_name:
            display_name = display_name.replace('\n', ' ')
            display_name = display_name[:100]
        m = ('depth %s tag %s id %-30s %-20s %s %s  ' %
             (item.depth, item.tag.name, item.id[:26],
              number, ' ' * 2 * item.depth, display_name))
        m += ' ' * (120 - len(m))
        s += '\n' + m
    return s


class Item(object):

    def __init__(self, tag, depth, name, _id, items):
        self.tag = tag
        self.name = name
        self.depth = depth
        self.id = _id
        self.items = items
        self.number = None
        if ":" in self.id:
            # Get "sub", "sec", "part", etc.
            self.header_level = self.id.split(":")[0]
        else:
            self.header_level = 'unknown'
            # logger.warn(self.id)

    def copy_excluding_levels(self, exclude_levels):
        items = []
        for _ in self.items:
            x = _.copy_excluding_levels(exclude_levels)
            if x.header_level not in exclude_levels:
                items.append(x)
        item = Item(
                tag=self.tag, depth=self.depth, name=self.name, _id=self.id, items=items)
        return item

    def to_html(self, root, max_levels):
        s = u''
        if not root:
            if MCDPManualConstants.ATTR_NONUMBER in self.tag.attrs:
                CLASS = MCDPManualConstants.CLASS_ONLY_NAME
            else:
                CLASS = MCDPManualConstants.CLASS_NUMBER_NAME

            s += (u"""<a class="toc_link toc_link-depth-%s %s toc_a_for_%s" href="#%s"></a>""" %
                  (self.depth, CLASS, self.header_level, self.id))

        if max_levels and self.items:
            s += '<ul class="toc_ul-depth-%s toc_ul_for_%s">' % (
                self.depth, self.header_level)
            for item in self.items:
                sitem = item.to_html(root=False, max_levels=max_levels - 1)
                sitem = indent(sitem, '  ')
                s += ('\n  <li class="toc_li-depth-%s toc_li_for_%s">\n%s\n  </li>' %
                      (self.depth, self.header_level, sitem))
            s += '\n</ul>'

        return s

    def depth_first_descendants(self):
        for item in self.items:
            yield item
            for item2 in item.depth_first_descendants():
                yield item2


def number_items2(root, res):
    counters = set(MCDPManualConstants.counters)

    # TODO: make configurable
    # style = get_style_book()
    style = get_style_duckietown()
    resets = style.resets
    labels = style.labels

    for c in counters:
        assert c in resets, c
        assert c in labels, c
    from collections import defaultdict
    counter_parents = defaultdict(lambda: set())
    for c, cc in resets.items():
        for x in cc:
            counter_parents[x].add(c)

    counter_state = {}
    for counter in counters:
        counter_state[counter] = 0

    for item in root.depth_first_descendants():
        counter = item.id.split(":")[0]

        nonumber = MCDPManualConstants.ATTR_NONUMBER in item.tag.attrs

        #         print('counter %s id %s %s' % (counter, item.id, counter_state))
        if counter in counters:

            if not nonumber:
                counter_state[counter] += 1
                for counter_to_reset in resets[counter]:
                    counter_state[counter_to_reset] = 0

            label_spec = labels[counter]
            what = label_spec.what
            number = render(label_spec.number, counter_state)

            if LABEL_NAME in item.tag.attrs:
                pass
                # msg = "Don't overwrite %s for element = %s" % (LABEL_NAME, item.tag.attrs[LABEL_NAME])
                # logger.warn(msg)
            else:
                item.tag.attrs[LABEL_NAME] = item.name

            if nonumber:
                item.tag.attrs[LABEL_WHAT] = what
                item.tag.attrs[LABEL_SELF] = item.name  # ??? render(label_spec.label_self, counter_state)
                item.tag.attrs[LABEL_WHAT_NUMBER_NAME] = item.name
                # item.tag.attrs[LABEL_WHAT_NUMBER] = None
                # item.tag.attrs[LABEL_NUMBER] = None
            else:
                item.tag.attrs[LABEL_WHAT] = what
                item.tag.attrs[LABEL_SELF] = render(label_spec.label_self, counter_state)

                if ZERO in item.tag.attrs[LABEL_SELF]:
                    msg = 'This has zero counter.'
                    res.note_error(msg, HTMLIDLocation.for_element(item.tag))
                if item.name is None:
                    item.tag.attrs[LABEL_WHAT_NUMBER_NAME] = what + ' ' + number
                else:
                    item.tag.attrs[LABEL_WHAT_NUMBER_NAME] = what + ' ' + number + ' - ' + item.name
                item.tag.attrs[LABEL_WHAT_NUMBER] = what + ' ' + number
                item.tag.attrs[LABEL_NUMBER] = number

            if item.tag.attrs.get('type', '') == 'slides':
                item.tag.attrs[LABEL_NAME] = u"🎦 " + item.tag.attrs[LABEL_NAME]

            allattrs = [LABEL_NAME, LABEL_WHAT, LABEL_WHAT_NUMBER_NAME, LABEL_NUMBER, LABEL_SELF]
            for c in counters:
                if c in counter_parents[counter] or c == counter:
                    attname = 'counter-%s' % c
                    allattrs.append(attname)
                    item.tag.attrs[attname] = counter_state[c]

            if item.tag.name == 'figure':
                # also copy to the caption
                for figcaption in item.tag.findAll(['figcaption']):
                    if figcaption.parent != item.tag:
                        continue
                    for x in allattrs:
                        figcaption.attrs[x] = item.tag.attrs[x]


LABEL_NAME = 'label-name'
LABEL_NUMBER = 'label-number'
LABEL_WHAT = 'label-what'
LABEL_SELF = 'label-self'
LABEL_WHAT_NUMBER_NAME = 'label-what-number-name'
LABEL_WHAT_NUMBER = 'label-what-number'


def render(s, counter_state):
    reps = {}
    for c, v in counter_state.items():
        for style in number_styles:
            reps['${%s|%s}' % (c, style)] = render_number(v, style)
        reps['${%s}' % c] = render_number(v, 'decimal')

    for k, v in reps.items():
        s = s.replace(k, v)
    return s


def check_no_patently_wrong_links(soup, res, location):
    for a in soup.select('a[href]'):
        href = a.attrs['href']
        if href.startswith('#http:') or href.startswith('#https:'):
            msg = """
This link is invalid:

    URL = %s

I think there is an extra "#" at the beginning.

Note that the Markdown syntax is:

    [description](URL)

where URL can be:

    1) using the fragment notation, such as

        URL = '#SECTIONID'

    for example:

        Look at [the section](#section-name)


    2) a regular URL, such as:

        URL = 'http://google.com'

    that is:

        Look at [the website](http://google.com)


You have mixed the two syntaxes.

You probably meant to write the url

    %s

but you added an extra "#" at the beginning that should have not been there.

Please remove the "#".

            """ % (href, href[1:])
            # note_error2(a, 'syntax error', )
            res.note_error(msg.lstrip(), HTMLIDLocation.for_element(a, location))


def has_a_remote_href(a):
    href = a.attrs['href']
    if href.startswith('+'):
        return True
    else:
        return False

def downcast_external(soup):
    for a in soup.select('a[href]'):
        href = a.attrs['href']

        if href.startswith('+'):
            s = href.index('#')
            frag = href[s+1:]
            book = href[1:s]
            href2 = '#%s/%s' % (book, frag)
            a.attrs['href'] = href2
            # a.attrs['external'] = href # XXX
            logger.debug('changing remote href %s to %s' % (href, href2))

@contract(raise_errors=bool)
def substituting_empty_links(soup, raise_errors=False, res=None,
                             extra_refs=None):
    """
        soup: where to look for references
        elemtn_to_modify: what to modify (if None, it is equal to soup)


        default style is [](#sec:systems)  "Chapter 10"

        You can also use "class":

            <a href='#sec:name' class='only_number'></a>

    """
    if extra_refs is None:
        extra_refs = Tag(name='div')
    if res is None:
        res = AugmentedResult()



    for le in get_empty_links_to_fragment(soup, extra_refs=extra_refs, res=res):
        a = le.linker
        element_id = le.eid
        element = le.linked

        if not element:
            msg = ('Cannot resolve reference "#%s"' % element_id)
            res.note_error(msg, HTMLIDLocation.for_element(a))

            a.append('? #%s' % element_id)
            if raise_errors:
                raise ValueError(msg)
            continue

        sub_link(a, element_id, element, res)

    for a in get_empty_links(soup):
        if has_a_remote_href(a):
            msg = "Ignoring the remote reference %s" % a.attrs['href']
            res.note_warning(msg, HTMLIDLocation.for_element(a))
            a.append('[%s]' % a.attrs['href'])
            continue

        href = a.attrs.get('href', '(not present)')
        if not href:
            href = '""'
        if href.startswith('python:'):
            continue

        if href.startswith('http:') or href.startswith('https:'):
            msg = """
This link text is empty:

    ELEMENT

Note that the syntax for links in Markdown is

    [link text](URL)

For the internal links (where URL starts with "#"), then the documentation
system can fill in the title automatically, leading to the format:

    [](#other-section)

However, this does not work for external sites, such as:

    [](MYURL)

So, you need to provide some text, such as:

    [this useful website](MYURL)

"""
            msg = msg.replace('ELEMENT', str(a))
            msg = msg.replace('MYURL', href)
            # note_error2(a, 'syntax error', msg.strip())

            res.note_error(msg, HTMLIDLocation.for_element(a))

        else:
            msg = """
This link is empty:

    ELEMENT

It might be that the writer intended for this
link to point to something, but they got the syntax wrong.

    href = %s

As a reminder, to refer to other parts of the document, use
the syntax "#ID", such as:

    See [](#fig:my-figure).

    See [](#section-name).

""" % href
        msg = msg.replace('ELEMENT', str(a))
        # note_error2(a, 'syntax error', msg.strip())
        res.note_error(msg, HTMLIDLocation.for_element(a))


def add_id_if_not_present(a, unique=None):
    if not 'id' in a.attrs:
        id_ = 'add-id-%s-%s' % (a.name, str(id(a)))
        if unique:
            id_ = unique + '-' + id_
        a.attrs['id'] = id_


def sub_link(a, element_id, element, res):
    """
        a: the link with href= #element_id
        element: the link to which we refer
    """
    assert isinstance(element, Tag)
    CLASS_ONLY_NUMBER = MCDPManualConstants.CLASS_ONLY_NUMBER
    CLASS_NUMBER_NAME = MCDPManualConstants.CLASS_NUMBER_NAME
    CLASS_ONLY_NAME = MCDPManualConstants.CLASS_ONLY_NAME

    if MCDPManualConstants.ATTR_NONUMBER in element.attrs:
        label_what_number = None
        label_number = None
        try:
            label_what = element.attrs[LABEL_WHAT]
            label_name = element.attrs[LABEL_NAME]
        except KeyError as e:
            msg = 'Cannot find %r in %s' % (e, element.attrs)
            raise Exception(msg)  # XXX

        classes = [CLASS_ONLY_NAME]
    else:
        if (not LABEL_WHAT_NUMBER in element.attrs) or \
                (not LABEL_NAME in element.attrs):
            msg = ('substituting_empty_links: Could not find attributes %s or %s in %s' %
                   (LABEL_NAME, LABEL_WHAT_NUMBER, compact_desc_tag(element)))

            res.note_error(msg, {'original': HTMLIDLocation(element_id),
                                 'reference': HTMLIDLocation.for_element(a)})
            return

        label_what_number = element.attrs[LABEL_WHAT_NUMBER]
        label_number = element.attrs[LABEL_NUMBER]
        label_what = element.attrs[LABEL_WHAT]
        label_name = element.attrs[LABEL_NAME]

        classes = list(a.attrs.get('class', []))  # bug: I was modifying

    if MCDPManualConstants.CLASS_TOC_LINK in classes:

        if not CLASS_ONLY_NAME in classes:
            s = Tag(name='span')
            s.string = label_what
            add_class(s, 'toc_what')
            a.append(s)

            a.append(' ')

            s = Tag(name='span')
            s.string = label_number
            add_class(s, 'toc_number')
            a.append(s)

            s = Tag(name='span')
            s.string = ' - '
            add_class(s, 'toc_sep')
            a.append(s)

        if label_name is not None and '<' in label_name:
            contents = bs(label_name)
            # sanitize the label name
            for br in contents.findAll('br'):
                br.replaceWith(NavigableString(' '))
            for _ in contents.findAll('a'):
                _.extract()

            contents.name = 'span'
            add_class(contents, 'toc_name')
            a.append(contents)
            # logger.debug('From label_name = %r to a = %r' % (label_name, a))
        else:
            if label_name is None:
                s = Tag(name='span')
                s.string = '(unnamed)'  # XXX
            else:
                s = bs(label_name)
                assert s.name == 'fragment'
                s.name = 'span'
                # add_class(s, 'produced-here') # XXX
            add_class(s, 'toc_name')
            a.append(s)

    else:

        if CLASS_ONLY_NUMBER in classes:
            label = label_number
        elif CLASS_NUMBER_NAME in classes:
            if label_name is None:
                label = label_what_number + \
                        ' - ' + '(unnamed)'  # warning
            else:
                label = label_what_number + ' - ' + label_name
        elif CLASS_ONLY_NAME in classes:
            if label_name is None:
                label = '(unnamed)'  # warning
            else:
                label = label_name
        else:
            # default behavior
            if string_starts_with(['fig:', 'tab:', 'bib:', 'code:'], element_id):
                label = label_what_number
            elif label_name is None:
                label = label_what_number
            else:
                label = label_what_number + ' - ' + label_name

        frag = bs(label)
        assert frag.name == 'fragment'
        frag.name = 'span'
        add_class(frag, 'reflabel')
        a.append(frag)

        # FIXME - I didn't understand
        # if 'base_url' in element.attrs:
        #     a['href'] = element.attrs['base_url'] + a['href']


def compact_desc_tag(element):
    t = Tag(name=element.name)
    t.attrs.update(element.attrs)
    t.append(' ... ')
    return str(t)


def string_starts_with(prefixes, s):
    return any([s.startswith(_) for _ in prefixes])


LinkElement = namedtuple('LinkElement', 'linker eid linked query')


def is_empty_link(a):
    empty = len(list(a.descendants)) == 0
    return empty


def get_empty_links(soup):
    """ Yields all the empty links """
    for element in soup.find_all('a'):
        if not is_empty_link(element):
            continue
        yield element


def get_empty_links_to_fragment(element_to_modify, extra_refs, res):
    """
        Find all empty links that have a reference to a fragment.
        yield LinkElement
    """
    # logger.debug('building index')
    # first find all elements by id

    id2element_local, duplicates = get_id2element(element_to_modify, 'id')
    id2element_extra, duplicates2 = get_id2element(extra_refs, 'id')

    for k in id2element_extra:
        if k in id2element_local:
            if 'ignore_if_conflict' in id2element_extra[k].attrs:
                continue

            msg = 'ID %s in cross references also contained locally.' % k

            def cut(x):
                if len(x) < 500:
                    return x
                else:
                    return x[:500] + ' ... '

            msg += '\n\n' + indent(cut(id2element_local[k]), '', 'local: ')
            msg += '\n\n' + indent(cut(id2element_extra[k]), '', 'crossrefs: ')
            res.note_error(msg, HTMLIDLocation.for_element(id2element_local[k]))
            logger.error(msg)

    id2element = {}
    id2element.update(id2element_extra)
    id2element.update(id2element_local)

    # logger.debug('building index done')

    for element in get_empty_links(element_to_modify):
        if not 'href' in element.attrs:
            continue

        href = element.attrs['href']
        if not href.startswith('#'):
            continue
        rest = href[1:]

        eid = rest
        query = None

        linked = id2element.get(eid, None)
        # noinspection PyArgumentList
        yield LinkElement(linker=element, eid=eid, linked=linked, query=query)


def get_ids_from_soup(soup):
    # XXX: redundant
    id2e = {}
    for e in soup.select('[id]'):
        id_ = e.attrs['id']
        id2e[id_] = e
    return id2e
